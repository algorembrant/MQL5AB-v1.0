from typing import Dict, List
from datetime import datetime

class MQL5Generator:
    """
    Generates pure MQL5 code from visual strategy definitions
    Strictly MT5 compatible - never uses MT4 functions
    """
    
    def __init__(self, strategy: Dict):
        self.strategy = strategy
        self.code_lines = []
        
    def generate(self) -> str:
        """Generate complete MQL5 Expert Advisor code"""
        self._add_header()
        self._add_input_parameters()
        self._add_global_variables()
        self._add_oninit()
        self._add_ondeinit()
        self._add_ontick()
        self._add_entry_logic()
        self._add_exit_logic()
        self._add_risk_management()
        self._add_utility_functions()
        
        return "\n".join(self.code_lines)
    
    def _add_header(self):
        """Add EA header and properties"""
        name = self.strategy.get('name', 'AlgoBot')
        description = self.strategy.get('description', 'Generated by MQL5 Algo Bot Builder')
        
        self.code_lines.extend([
            "//+------------------------------------------------------------------+",
            f"//| {name:64} |",
            "//| Generated by MQL5 Algo Bot Builder                               |",
            f"//| {datetime.now().strftime('%Y.%m.%d %H:%M')}                                                    |",
            "//+------------------------------------------------------------------+",
            "#property copyright \"MQL5 Algo Bot Builder\"",
            "#property link      \"https://your-platform.com\"",
            f"#property description \"{description}\"",
            "#property version   \"1.00\"",
            "#property strict",
            "",
            "// Include trade library",
            "#include <Trade\\Trade.mqh>",
            ""
        ])
    
    def _add_input_parameters(self):
        """Add input parameters"""
        risk_mgmt = self.strategy.get('risk_management', {})
        risk_percent = risk_mgmt.get('risk_percent', 2.0)
        
        self.code_lines.extend([
            "//+------------------------------------------------------------------+",
            "//| Input Parameters                                                  |",
            "//+------------------------------------------------------------------+",
            f"input double RiskPercent = {risk_percent};  // Risk per trade (%)",
            "input int MagicNumber = 123456;              // Magic number",
            "input string CommentPrefix = \"AlgoBot_\";   // Trade comment prefix",
            "input bool UseTrailingStop = false;          // Enable trailing stop",
            "input double TrailingStopPips = 20.0;        // Trailing stop distance (pips)",
            "input double TrailingStepPips = 5.0;         // Trailing step (pips)",
            ""
        ])
    
    def _add_global_variables(self):
        """Add global variables"""
        self.code_lines.extend([
            "//+------------------------------------------------------------------+",
            "//| Global Variables                                                  |",
            "//+------------------------------------------------------------------+",
            "CTrade trade;",
            "double pipSize;",
            "int barsTotal;",
            "",
            "// Strategy state",
            "bool positionOpen = false;",
            "ulong currentTicket = 0;",
            ""
        ])
    
    def _add_oninit(self):
        """Add OnInit function"""
        symbol = self.strategy.get('symbol', 'EURUSD')
        
        self.code_lines.extend([
            "//+------------------------------------------------------------------+",
            "//| Expert initialization function                                    |",
            "//+------------------------------------------------------------------+",
            "int OnInit()",
            "{",
            "   // Initialize trade object",
            "   trade.SetExpertMagicNumber(MagicNumber);",
            "   trade.SetDeviationInPoints(10);",
            "   trade.SetTypeFilling(ORDER_FILLING_FOK);",
            "   trade.SetAsyncMode(false);",
            "   ",
            "   // Calculate pip size",
            f"   int digits = (int)SymbolInfoInteger(\"{symbol}\", SYMBOL_DIGITS);",
            "   if(digits == 3 || digits == 5)",
            "      pipSize = _Point * 10;",
            "   else",
            "      pipSize = _Point;",
            "   ",
            "   // Initialize bars count",
            f"   barsTotal = iBars(\"{symbol}\", PERIOD_CURRENT);",
            "   ",
            "   Print(\"Expert Advisor initialized successfully\");",
            "   return(INIT_SUCCEEDED);",
            "}",
            ""
        ])
    
    def _add_ondeinit(self):
        """Add OnDeinit function"""
        self.code_lines.extend([
            "//+------------------------------------------------------------------+",
            "//| Expert deinitialization function                                  |",
            "//+------------------------------------------------------------------+",
            "void OnDeinit(const int reason)",
            "{",
            "   Print(\"Expert Advisor deinitialized, reason: \", reason);",
            "}",
            ""
        ])
    
    def _add_ontick(self):
        """Add OnTick function - main logic"""
        symbol = self.strategy.get('symbol', 'EURUSD')
        
        self.code_lines.extend([
            "//+------------------------------------------------------------------+",
            "//| Expert tick function                                              |",
            "//+------------------------------------------------------------------+",
            "void OnTick()",
            "{",
            "   // Check for new bar",
            f"   int bars = iBars(\"{symbol}\", PERIOD_CURRENT);",
            "   if(bars == barsTotal)",
            "      return;",
            "   barsTotal = bars;",
            "   ",
            "   // Update position state",
            "   UpdatePositionState();",
            "   ",
            "   // Check exit conditions",
            "   if(positionOpen)",
            "   {",
            "      CheckExitConditions();",
            "      if(UseTrailingStop)",
            "         TrailStop();",
            "      return;",
            "   }",
            "   ",
            "   // Check entry conditions",
            "   CheckEntryConditions();",
            "}",
            ""
        ])
    
    def _add_entry_logic(self):
        """Generate entry logic from visual elements"""
        entry_rules = self.strategy.get('entry_rules', {})
        visual_elements = self.strategy.get('visual_elements', [])
        symbol = self.strategy.get('symbol', 'EURUSD')
        
        self.code_lines.extend([
            "//+------------------------------------------------------------------+",
            "//| Check Entry Conditions                                            |",
            "//+------------------------------------------------------------------+",
            "void CheckEntryConditions()",
            "{",
            f"   double ask = SymbolInfoDouble(\"{symbol}\", SYMBOL_ASK);",
            f"   double bid = SymbolInfoDouble(\"{symbol}\", SYMBOL_BID);",
            "   ",
            "   // Get current candle data",
            "   double close1 = iClose(_Symbol, PERIOD_CURRENT, 1);",
            "   double open1 = iOpen(_Symbol, PERIOD_CURRENT, 1);",
            "   double high1 = iHigh(_Symbol, PERIOD_CURRENT, 1);",
            "   double low1 = iLow(_Symbol, PERIOD_CURRENT, 1);",
            "   "
        ])
        
        # Generate conditions from visual elements
        buy_conditions = []
        sell_conditions = []
        
        for element in visual_elements:
            if element['type'] == 'horizontal_line':
                price = element['price']
                if element.get('action') == 'buy_above':
                    buy_conditions.append(f"close1 > {price}")
                elif element.get('action') == 'sell_below':
                    sell_conditions.append(f"close1 < {price}")
            
            elif element['type'] == 'zone':
                upper = element['upper']
                lower = element['lower']
                if element.get('action') == 'buy_in_zone':
                    buy_conditions.append(f"(close1 >= {lower} && close1 <= {upper})")
                elif element.get('action') == 'sell_in_zone':
                    sell_conditions.append(f"(close1 >= {lower} && close1 <= {upper})")
        
        # Generate buy logic
        if buy_conditions:
            condition_str = " && ".join(buy_conditions)
            self.code_lines.extend([
                f"   // Buy conditions",
                f"   if({condition_str})",
                "   {",
                "      ExecuteBuy();",
                "   }",
                "   "
            ])
        
        # Generate sell logic
        if sell_conditions:
            condition_str = " && ".join(sell_conditions)
            self.code_lines.extend([
                f"   // Sell conditions",
                f"   if({condition_str})",
                "   {",
                "      ExecuteSell();",
                "   }",
                "   "
            ])
        
        self.code_lines.append("}")
        self.code_lines.append("")
    
    def _add_exit_logic(self):
        """Generate exit logic"""
        exit_rules = self.strategy.get('exit_rules', {})
        sl_pips = exit_rules.get('stop_loss_pips', 50)
        tp_pips = exit_rules.get('take_profit_pips', 100)
        
        self.code_lines.extend([
            "//+------------------------------------------------------------------+",
            "//| Check Exit Conditions                                             |",
            "//+------------------------------------------------------------------+",
            "void CheckExitConditions()",
            "{",
            "   // Exit logic is handled by SL/TP",
            "   // Additional exit conditions can be added here",
            "}",
            ""
        ])
    
    def _add_risk_management(self):
        """Add risk management functions"""
        symbol = self.strategy.get('symbol', 'EURUSD')
        exit_rules = self.strategy.get('exit_rules', {})
        sl_pips = exit_rules.get('stop_loss_pips', 50)
        tp_pips = exit_rules.get('take_profit_pips', 100)
        
        self.code_lines.extend([
            "//+------------------------------------------------------------------+",
            "//| Execute Buy Order                                                 |",
            "//+------------------------------------------------------------------+",
            "void ExecuteBuy()",
            "{",
            f"   double ask = SymbolInfoDouble(\"{symbol}\", SYMBOL_ASK);",
            f"   double bid = SymbolInfoDouble(\"{symbol}\", SYMBOL_BID);",
            "   ",
            "   // Calculate position size based on risk",
            f"   double stopLoss = ask - ({sl_pips} * pipSize);",
            "   double takeProfit = ask + ({tp_pips} * pipSize);",
            "   double lotSize = CalculateLotSize(ask - stopLoss);",
            "   ",
            "   if(lotSize > 0)",
            "   {",
            "      if(trade.Buy(lotSize, _Symbol, ask, stopLoss, takeProfit, CommentPrefix + \"Buy\"))",
            "      {",
            "         currentTicket = trade.ResultOrder();",
            "         Print(\"Buy order executed, ticket: \", currentTicket);",
            "      }",
            "      else",
            "      {",
            "         Print(\"Buy order failed, error: \", GetLastError());",
            "      }",
            "   }",
            "}",
            "",
            "//+------------------------------------------------------------------+",
            "//| Execute Sell Order                                                |",
            "//+------------------------------------------------------------------+",
            "void ExecuteSell()",
            "{",
            f"   double ask = SymbolInfoDouble(\"{symbol}\", SYMBOL_ASK);",
            f"   double bid = SymbolInfoDouble(\"{symbol}\", SYMBOL_BID);",
            "   ",
            "   // Calculate position size based on risk",
            f"   double stopLoss = bid + ({sl_pips} * pipSize);",
            f"   double takeProfit = bid - ({tp_pips} * pipSize);",
            "   double lotSize = CalculateLotSize(stopLoss - bid);",
            "   ",
            "   if(lotSize > 0)",
            "   {",
            "      if(trade.Sell(lotSize, _Symbol, bid, stopLoss, takeProfit, CommentPrefix + \"Sell\"))",
            "      {",
            "         currentTicket = trade.ResultOrder();",
            "         Print(\"Sell order executed, ticket: \", currentTicket);",
            "      }",
            "      else",
            "      {",
            "         Print(\"Sell order failed, error: \", GetLastError());",
            "      }",
            "   }",
            "}",
            "",
            "//+------------------------------------------------------------------+",
            "//| Calculate Lot Size Based on Risk                                  |",
            "//+------------------------------------------------------------------+",
            "double CalculateLotSize(double stopLossDistance)",
            "{",
            "   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);",
            "   double riskAmount = accountBalance * (RiskPercent / 100.0);",
            "   ",
            f"   double tickValue = SymbolInfoDouble(\"{symbol}\", SYMBOL_TRADE_TICK_VALUE);",
            f"   double tickSize = SymbolInfoDouble(\"{symbol}\", SYMBOL_TRADE_TICK_SIZE);",
            "   ",
            "   double pipValue = (tickValue / tickSize) * pipSize;",
            "   double stopLossPips = stopLossDistance / pipSize;",
            "   ",
            "   double lotSize = riskAmount / (stopLossPips * pipValue);",
            "   ",
            "   // Round to lot step",
            f"   double lotStep = SymbolInfoDouble(\"{symbol}\", SYMBOL_VOLUME_STEP);",
            "   lotSize = MathFloor(lotSize / lotStep) * lotStep;",
            "   ",
            "   // Ensure within limits",
            f"   double minLot = SymbolInfoDouble(\"{symbol}\", SYMBOL_VOLUME_MIN);",
            f"   double maxLot = SymbolInfoDouble(\"{symbol}\", SYMBOL_VOLUME_MAX);",
            "   lotSize = MathMax(minLot, MathMin(lotSize, maxLot));",
            "   ",
            "   return lotSize;",
            "}",
            ""
        ])
    
    def _add_utility_functions(self):
        """Add utility functions"""
        self.code_lines.extend([
            "//+------------------------------------------------------------------+",
            "//| Update Position State                                             |",
            "//+------------------------------------------------------------------+",
            "void UpdatePositionState()",
            "{",
            "   positionOpen = false;",
            "   ",
            "   for(int i = PositionsTotal() - 1; i >= 0; i--)",
            "   {",
            "      ulong ticket = PositionGetTicket(i);",
            "      if(PositionSelectByTicket(ticket))",
            "      {",
            "         if(PositionGetInteger(POSITION_MAGIC) == MagicNumber &&",
            "            PositionGetString(POSITION_SYMBOL) == _Symbol)",
            "         {",
            "            positionOpen = true;",
            "            currentTicket = ticket;",
            "            break;",
            "         }",
            "      }",
            "   }",
            "}",
            "",
            "//+------------------------------------------------------------------+",
            "//| Trailing Stop                                                     |",
            "//+------------------------------------------------------------------+",
            "void TrailStop()",
            "{",
            "   if(!PositionSelectByTicket(currentTicket))",
            "      return;",
            "   ",
            "   double currentSL = PositionGetDouble(POSITION_SL);",
            "   double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);",
            "   ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);",
            "   ",
            "   double currentPrice = (posType == POSITION_TYPE_BUY) ? ",
            "                         SymbolInfoDouble(_Symbol, SYMBOL_BID) : ",
            "                         SymbolInfoDouble(_Symbol, SYMBOL_ASK);",
            "   ",
            "   double trailDistance = TrailingStopPips * pipSize;",
            "   double trailStep = TrailingStepPips * pipSize;",
            "   double newSL;",
            "   ",
            "   if(posType == POSITION_TYPE_BUY)",
            "   {",
            "      newSL = currentPrice - trailDistance;",
            "      if(newSL > currentSL + trailStep && newSL > openPrice)",
            "      {",
            "         trade.PositionModify(currentTicket, newSL, PositionGetDouble(POSITION_TP));",
            "      }",
            "   }",
            "   else",
            "   {",
            "      newSL = currentPrice + trailDistance;",
            "      if(newSL < currentSL - trailStep && newSL < openPrice)",
            "      {",
            "         trade.PositionModify(currentTicket, newSL, PositionGetDouble(POSITION_TP));",
            "      }",
            "   }",
            "}",
            "//+------------------------------------------------------------------+"
        ])
    
    def get_code(self) -> str:
        """Return generated code"""
        return "\n".join(self.code_lines)